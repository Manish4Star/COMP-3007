;Name: Muhammad Mustafa
;Student#: 100823576
;COMP 3007: ASSIGNMENT#2
;all the coding for this assignment was done in Scheme R5RS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(display "TESTING")
(newline)
(display "--------")
(newline)
;Q1) Making procedures to make, add, subtract and divide given intervals:
(define (make-interval lower upper)
  (if(<= lower upper)
       (cons lower upper)
       (display "invalid interval")))
(define (start lb) (car lb))
(define (end ub) (cdr ub))
(define (print-interval interval)
  (display "[")(display (start interval))(display ",")(display (end interval))(display "]"))
(define (add-interval i1 i2)
  (make-interval (+ (start i1) (start i2)) (+ (end i1) (end i2))))
(display "Q1)")(newline)
(display "Addition: [a,b] + [c,d] = [a+c,b+d]") (newline)
(display "add-interval: [2,3] + [4,5] = exepected [6,8] --> result:") (print-interval(add-interval(make-interval 2 3) (make-interval 4 5)))(newline)
(newline)
(define (subtract-interval i1 i2)
  (make-interval (- (start i1) (start i2)) (- (end i1) (end i2))))
(display "Subtract: [a,b] - [c,d] = [a-d,b-c]") (newline)
(display "subtract-interval: [2,3] - [4,5] = exepected [-2,-2] --> result:") (print-interval(subtract-interval(make-interval 2 3) (make-interval 4 5)))(newline)
(newline)
(define (multiply-interval i1 i2)
  (make-interval (min (*(start i1) (start i2))(*(start i1)(end i2))(*(end i1)(start i2))(*(end i1)(end i2)))
                 (max (*(start i1) (start i2))(*(start i1)(end i2))(*(end i1)(start i2))(*(end i1)(end i2)))))
(display "Multiply: [a,b] * [c,d] = [min(ac,ad,bc,bd), max(ac,ad,bc,bd)]") (newline)
(display "multiply-interval: [2,3] * [4,5] = exepected [8,15] --> result:") (print-interval(multiply-interval(make-interval 2 3) (make-interval 4 5)))(newline)
(newline)
(define (divide-interval i1 i2)
  (if(<= (start i2) 0)
     (display "it is division by 0...invalid!!")
     (multiply-interval i1 (make-interval (/ 1 (end i2)) (/ 1 (start i2))))))
(display "Divide: [a,b] / [c,d] = [a,b] * [1/d,1/c] if [c,d] does not contain 0, otherwise error") (newline)
(display "divide-interval: [2,3] / [4,5] = exepected [2/5,3/4] --> result:") (print-interval(divide-interval(make-interval 2 3) (make-interval 4 5)))(newline)
(newline)
(display "invalid interval test: ") (newline)
(display "[3,2] + [6,2] = exepected invalid interval--> result:") (make-interval 6 2) (newline)
(newline)
(display "Divide:   [a,b] / [c,d] = [a,b] * [1/d,1/c] if [c,d] does not contain 0, otherwise error") (newline)
(display "divide-interval: [5,10] / [-10,30] = exepected invalid!! --> result:") (divide-interval(make-interval 5 10) (make-interval -10 30))(newline)
(newline)
(display "......................................................................................................................................................")(newline)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Q2) Filling in missing expressions to complete defintions
(define (accumulate operator initial sequence) 
    (if (null? sequence) 
        initial 
        (operator (car sequence) (accumulate operator initial (cdr sequence)))))
(display "Q2a) (define (my-map proc sequence) 
   (accumulate (lambda (x y) ??? '() sequence))")(newline)
(display "ANSWER: The funtion doubles every element in the list using procedure double and test-list as the sequence")(newline)
(define (my-map proc sequence)
    (accumulate (lambda (x y) (cons (proc x) y)) '() sequence))
;The answer above grabs the first element to the list does the procedure on it and holds the rest of the rest of the list for later operation
(display "??? ---> (accumulate (lambda (x y) (cons (proc x) y)) '() sequence))")(newline)
(display "list provided: (list 1 2 3 4); expected answer: (2 4 6 8); result: ")
(define test-list1 (list 1 2 3 4))
(define (double x) (* 2 x))
(my-map double test-list1)
(newline)
(display "Q2b) (define (my-append seq1 seq2)
    (accumulate cons ??? ???))")(newline)
(display "ANSWER: joining two lists together")(newline)
(define (my-append seq1 seq2)
    (accumulate cons seq2 seq1))
;Since joining the list, we would have to hold elements from the seq2 and later they cons back together in a complete large list
(display "??? ---> seq2 seq1; in that order")(newline)
(display "list provided: (1 2 3 4) (5 6 7 8); expected answer: (1 2 3 4 5 6 7 8); result: ")
(define test-list2 (list 5 6 7 8))
(my-append test-list1 test-list2)
(newline)
(display "Q2c) (define (my-length sequence)
	(accumulate ??? 0 sequence))")(newline)
(display "ANSWER: Showing the length of the list")(newline)
(define (my-length sequence)
	(accumulate  (lambda(x y) (+ 1 y))0 sequence))
(display "??? ---> (lambda(x y) (+ 1 y))") (newline)
(display "list provided: (1 2 3 4); expected answer: 4; result: ")
(my-length test-list1)
(newline)
(display "................................................................................................................................................")(newline)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Q3a)(define (special-cons x y)
   ;(lambda (m) (m x y)))
(display "Q3a) Special-car and Special-cdr implementation: ") (newline)
(define (special-cons x y)
   (lambda (m) (m x y)))
(define (special-car set)
  (set (lambda (x y) x)))
(define (special-cdr set)
  (set (lambda (x y) y)))
(display "(define test-cons (special-cons 1 2)): ")(newline)
(define test-cons (special-cons 1 2))
(special-car test-cons)
(special-cdr test-cons)
(display "testing special-car(special-cons 'x 'y)): ")(special-car (special-cons 'x 'y))
(display "testing special-cdr(special-cons 'x 'y)): ")(special-cdr (special-cons 'x 'y))(newline)

;Q3b) alternative representation of pairs:
(display "Q3b) alternative method:")(newline)
(define (special-consalt x y)
  (let ((ca x)
        (cd y))
    (define (dispatch which)
      (cond ((eq? which 'ca) ca)
            ((eq? which 'cd) cd)
            (else "does not exist")))
    dispatch))
(define (special-caralt pair)
  (pair 'ca))
(define (special-cdralt pair)
  (pair 'cd))
(define (new-pair a b)
    (define (get-value index)
        (cond ((= index 1) a)
              ((= index 2) b)
              (else '())))
    (lambda (index) (get-value index)))
(display "testing---(special-caralt (special-consalt 2 3)): ")(special-caralt (special-consalt 2 3))
(display "testing---(special-cdralt (special-consalt 2 3)): ")(special-cdralt (special-consalt 2 3))
(newline)

;Q3c) Create a procedure (triple x y z) that constructs a triplet EG.
;(define a (triple 1 2 3))
;(first a) → 1
;(second a) → 2
;(third a) → 3
(display "Q3c) Create a procedure (triple x y z) that constructs a triplet: ")(newline)
(define (triple x y z)
  (let ((first x)
        (second y)
        (third z))
    (define (dispatch which)
      (cond ((eq? which 'first) first)
            ((eq? which 'second) second)
            ((eq? which 'third) third)))
    dispatch))
(define (first sample)
  (sample 'first))
(define (second sample)
  (sample 'second))
(define (third sample)
  (sample 'third))
(display "(define example (triple 10 23 33)); result: ")(newline)
(define example (triple 10 23 33))
(first example)
(second example)
(third example)
(newline)
(display "................................................................................................................................................")(newline)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;Q4a) Define a procedure (subsets x) that takes a list as a single argument and returns all 2n subsets of that list, i.e., the power set of the list.
;(subsets '(a b c)) → (() (c) (b) (b c) (a) (a c) (a b) (a b c))
(display "Q4a) a procedure (subsets x) that takes a list as a single argument and returns all 2n subsets of that list: ")
(define (subsets set)
  (if (null? set)
      '(())
      (let ((left-over (subsets (cdr set))))
        (append (map (lambda (x) (cons (car set) x))left-over)
                left-over))))
(newline)
(display "subsets '(a b c): expected: (() (c) (b) (b c) (a) (a c) (a b) (a b c)); result: ")
(subsets '(a b c))
(display "subsets '(1 2 3): expected: (() (3) (2) (2 3) (1) (1 3) (1 2) (1 2 3)); result: ")
(subsets '(1 2 3))
(newline)

;Q4b)Define an iterative function (intersection-set-iter set1 set2) that returns the intersection of the two sets
(display "Q4b) Define an iterative function (intersection-set-iter set1 set2) that returns the intersection of the two sets: ")
(define (match a b)
  (cond ((null? b) #f)
        ((eq? a (car b)) #t)
        (else (match a (cdr b)))))
(define (intersection-set-iter set1 set2)
  (if (null? set1) '() 
      (let ((found (match (car set1) set2)))
        (cond ((null? set1) '(()))
              (found (cons (car set1) (intersection-set-iter (cdr set1) set2)))
              (else (intersection-set-iter (cdr set1) set2))))))
(newline)
(display "set1 (3 5 7 9 10) & set2 (1 3 5 2 6 8 4 19 10) intersection expected: (3 5 10); result: ")
(define set1 (list 3 5 7 9 10))
(define set2 (list 1 3 5 2 6 8 4 19 10))
(intersection-set-iter set1 set2)
(display "set3 (12) & set4 (1 2) intersection expected: '(); result: ")
(define set3 (list 12))
(define set4 (list 1 2))
(intersection-set-iter set3 set4)
(newline)

;Q4c)Using filter (see course notes), define a procedure (intersection-set set1 set2) that returns the intersection of the two lists
(display "Q4c) Using filter (see course notes), define a procedure (intersection-set set1 set2) that returns the intersection of the two lists")
(define (filter predicate sequence)
    (cond ((null? sequence) '())
          ((predicate (car sequence)) #t) 
          (else (filter predicate (cdr sequence)))))
(define (intersection-set-iter4c set1 set2)
  (if (null? set1) '()
      (let ((found (filter (lambda (x) (if (= (car set1) x) #t #f)) set2)))
        (cond ((null? set1) '(()))
              (found (cons (car set1) (intersection-set-iter4c (cdr set1) set2)))
              (else (intersection-set-iter4c (cdr set1) set2))))))
(newline)
(display "set1 (3 5 7 9 10) & set2 (1 3 5 2 6 8 4 9 19 10) intersection expected: (3 5 9 10); result: ")
(define set1 (list 3 5 7 9 10))
(define set2 (list 1 3 5 2 6 8 9 4 19 10))
(intersection-set-iter4c set1 set2)
(newline)
(display "................................................................................................................................................")(newline)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(display "Q5a) Define a recursive procedure (repeated f n) that applies the function f n times to an argument.
E.g.: ((repeated sqr 3) 2) → 256 ;i.e., (sqr (sqr (sqr 2)))")
(define (compose f g)(lambda (x) (f (g x))))
(define (sqr x)
  (* x x))
(define (helper f n x)
  (if (= n 1) (f x) (f (helper (- n 1) x))))
(define (repeated f n)  
  (define (helper f n x)
    (if (= n 1) (f x) (f (helper f (- n 1) x))))
  (lambda (y) (helper f n y)))
(newline)
(display "((repeated sqr 3) 2) → 256 ;i.e., (sqr (sqr (sqr 2))); result:")
((repeated sqr 3)2)
(newline)

(display "Q5b) Rewrite the 5a) procedure as an iterative process")
(define (compose f g)(lambda (x) (f (g x))))
(define (sqr x)
  (* x x))
(define (helper f n x)
  (if (= n 1) (f x) (f (helper (- n 1) x))))
(define (repeated-itr f n)  
  (define (helper f n x)
    (if (= n 1) (f x) (helper f (- n 1) (f x))))
  (lambda (y) (helper f n y)))
(newline)
(display "((repeated-itr sqr 3) 2) → 256 ;i.e., (sqr (sqr (sqr 2))); result:")
((repeated-itr sqr 3)2)